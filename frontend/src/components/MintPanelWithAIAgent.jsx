import React, { useState } from 'react';
import { useAccount, useContractWrite } from 'wagmi';
import NFTABI from '../abis/MyAI_NFT.json';

// Deployed ERC721 contract address on DharmaChain
const NFT_CONTRACT_ADDRESS = "0xF706ddBc70B90736eB3E44EEC340e5B4EeD46922";

/**
 * MintPanelWithAIAgent component integrates the AI Agent process for generating NFT data.
 *
 * Process Overview:
 * 1. User enters a descriptive prompt.
 * 2. The component calls the Hugging Face Inference API (Stable Diffusion) to generate an image.
 * 3. The binary image response is converted to a base64 data URL.
 * 4. The base64 image is converted to a File object.
 * 5. The image file is uploaded to Pinata (pinFileToIPFS) to obtain its IPFS URL.
 * 6. NFT metadata JSON is constructed (with name, description, image URL, and attributes) and uploaded to Pinata (pinJSONToIPFS) to retrieve the final tokenURI.
 * 7. The generated image preview and metadata are displayed, and the tokenURI field is auto-filled.
 * 8. The tokenURI can then be used to mint the NFT via a smart contract call.
 */
export default function MintPanelWithAIAgent() {
  const { address, isConnected } = useAccount();

  // State variables for user prompt, image preview, metadata, tokenURI, loading state, and error messages.
  const [prompt, setPrompt] = useState('');
  const [imagePreview, setImagePreview] = useState('');
  const [nftMetadata, setNftMetadata] = useState(null);
  const [tokenURI, setTokenURI] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Setup contract write hook (mintNFT(address, tokenURI)) via Wagmi.
  const { write: mintNFT, isLoading: minting, isSuccess } = useContractWrite({
    address: NFT_CONTRACT_ADDRESS,
    abi: NFTABI,
    functionName: 'mintNFT',
    args: [address, tokenURI],
    mode: 'recklesslyUnprepared',
    skipSimulate: true,
    onError(error) {
        console.error("Mint NFT error:", error);
    },
    onSuccess(data) {
        console.log("Mint NFT successful:", data);
    },
  });

  /**
   * generateNFTData handles the entire AI Agent process:
   * 1. Calls the Hugging Face Inference API using the provided prompt.
   * 2. Converts the binary image response (blob) into a base64 data URL.
   * 3. Converts the base64 image to a File object.
   * 4. Uploads the image file to Pinata via the pinFileToIPFS endpoint.
   * 5. Constructs NFT metadata JSON and uploads it to Pinata via the pinJSONToIPFS endpoint.
   * 6. Updates the component state with the generated image, metadata, and tokenURI.
   */
  const generateNFTData = async () => {
    setLoading(true);
    setError(null);
    try {
      // Step 1: Call the Hugging Face Inference API.
      const stableDiffusionUrl = process.env.REACT_APP_STABLE_DIFFUSION_API_URL;
      const stableDiffusionApiKey = process.env.REACT_APP_STABLE_DIFFUSION_API_KEY;
      const stableResponse = await fetch(stableDiffusionUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${stableDiffusionApiKey}`,
        },
        // Hugging Face expects the input under the "inputs" key.
        body: JSON.stringify({ inputs: prompt }),
      });

      if (!stableResponse.ok) {
        throw new Error("Stable Diffusion API request failed");
      }

      // Step 2: Convert the binary image response to a blob and then to a base64 data URL.
      const imageBlob = await stableResponse.blob();
      const generatedImage = await blobToDataURL(imageBlob);
      setImagePreview(generatedImage);

      // Step 3: Convert the base64 image to a File object.
      const imageFile = dataURLtoFile(generatedImage, "generated.png");

      // Step 4: Upload image file to Pinata.
      const pinataApiKey = process.env.REACT_APP_PINATA_API_KEY;
      const pinataApiSecret = process.env.REACT_APP_PINATA_API_SECRET;
      const imageFormData = new FormData();
      imageFormData.append('file', imageFile);

      const ipfsImageResponse = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
        method: 'POST',
        headers: {
          pinata_api_key: pinataApiKey,
          pinata_secret_api_key: pinataApiSecret,
        },
        body: imageFormData,
      });

      if (!ipfsImageResponse.ok) {
        throw new Error("Image upload to Pinata failed");
      }

      const ipfsImageData = await ipfsImageResponse.json();
      // The response should include an IpfsHash field.
      const imageCID = ipfsImageData.IpfsHash;
      const imageIPFSUrl = `https://gateway.pinata.cloud/ipfs/${imageCID}`;

      // Step 5: Construct NFT metadata JSON.
      const metadata = {
        name: prompt ? `AI NFT: ${prompt}` : "AI Generated NFT",
        description: "This NFT was automatically generated by AI with a futuristic tech style.",
        image: imageIPFSUrl,
        attributes: [
          { trait_type: "Prompt", value: prompt },
          { trait_type: "Generated At", value: new Date().toISOString() },
        ]
      };

      // Step 6: Upload metadata JSON to Pinata.
      const ipfsMetadataResponse = await fetch("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          pinata_api_key: pinataApiKey,
          pinata_secret_api_key: pinataApiSecret,
        },
        body: JSON.stringify({ pinataContent: metadata }),
      });

      if (!ipfsMetadataResponse.ok) {
        throw new Error("Metadata upload to Pinata failed");
      }

      const ipfsMetadataData = await ipfsMetadataResponse.json();
      const metadataCID = ipfsMetadataData.IpfsHash;
      const metadataIPFSUrl = `https://gateway.pinata.cloud/ipfs/${metadataCID}`;

      // Step 7: Update state with generated metadata and tokenURI.
      setNftMetadata(metadata);
      setTokenURI(metadataIPFSUrl);
    } catch (err) {
      console.error(err);
      setError(err.message);
    }
    setLoading(false);
  };

  /**
   * blobToDataURL converts a Blob object into a base64 encoded data URL.
   * @param {Blob} blob - The Blob object.
   * @returns {Promise<string>} - A promise that resolves to a base64 data URL.
   */
  const blobToDataURL = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  };

  /**
   * dataURLtoFile converts a base64 data URL to a File object.
   * @param {string} dataurl - The base64 encoded data URL.
   * @param {string} filename - The desired filename.
   * @returns {File} - The resulting File object.
   */
  const dataURLtoFile = (dataurl, filename) => {
    const arr = dataurl.split(',');
    const mimeMatch = arr[0].match(/:(.*?);/);
    if (!mimeMatch) throw new Error("Invalid data URL");
    const mime = mimeMatch[1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], filename, { type: mime });
  };

  if (!isConnected) {
    return <div>Please connect your wallet.</div>;
  }

  return (
    <div>
      <h2>Generate NFT Data with AI Agent</h2>
      {/* User prompt input */}
      <div>
        <input
          type="text"
          placeholder="Enter a description, e.g., 'Generate a futuristic tech style robot image'"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          style={{ width: '300px' }}
        />
        <button onClick={generateNFTData} disabled={loading || !prompt}>
          {loading ? "Generating..." : "Generate NFT Data"}
        </button>
      </div>
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      
      {/* Display generated image preview */}
      {imagePreview && (
        <div>
          <h3>Generated Image Preview</h3>
          <img src={imagePreview} alt="Generated NFT" style={{ maxWidth: '300px' }} />
        </div>
      )}
      
      {/* Display NFT metadata details */}
      {nftMetadata && (
        <div>
          <h3>NFT Metadata</h3>
          <pre>{JSON.stringify(nftMetadata, null, 2)}</pre>
        </div>
      )}
      
      {/* Mint section: display tokenURI and mint button */}
      <div>
        <h3>Mint NFT</h3>
        <p><strong>TokenURI:</strong> {tokenURI}</p>
        <button onClick={() => mintNFT()} disabled={!tokenURI || minting}>
          {minting ? "Minting..." : "Mint NFT"}
        </button>
        {isSuccess && <p>NFT minted successfully! Check your NFT on the blockchain.</p>}
      </div>
    </div>
  );
}
